--- libvncserver/websockets.c.orig	2014-10-21 17:57:11.000000000 +0200
+++ libvncserver/websockets.c	2016-08-23 19:07:52.000000000 +0200
@@ -231,7 +231,7 @@
         scheme = "ws";
     }
 
-    if (strncmp(bbuf, "GET ", 4) != 0) {
+    if (!cl->sslctx && strncmp(bbuf, "GET ", 4) != 0) {
       rfbErr("webSocketsHandshake: invalid client header\n");
       return FALSE;
     }
@@ -505,9 +505,17 @@
 static int
 ws_read(rfbClientPtr cl, char *buf, int len)
 {
-    int n;
+    int n, n2;
     if (cl->sslctx) {
 	n = rfbssl_read(cl, buf, len);
+	if (n > 0) {
+	    while (n != len) {
+		n2 = rfbssl_read(cl, buf+n, len-n);
+		if (n2 <= 0)
+		    break;
+		n += n2;
+	    }
+	}
     } else {
 	n = read(cl->sock, buf, len);
     }
@@ -660,8 +668,17 @@
     buf = wsctx->codeBuf;
     header = (ws_header_t *)wsctx->codeBuf;
 
+#if 0
     ret = ws_peek(cl, buf, B64LEN(len) + WSHLENMAX);
-
+#else
+#define WSHLENMIN 6
+    ret = ws_read(cl, buf, WSHLENMIN);
+    if (ret != WSHLENMIN) {
+	rfbLog("broken header");
+	errno = EIO;
+	goto spor;
+    }
+#endif
     if (ret < 2) {
         /* save errno because rfbErr() will tamper it */
         if (-1 == ret) {
@@ -695,6 +712,7 @@
     if (flength < 126) {
 	fhlen = 2;
 	mask = header->u.m;
+#if 0
     } else if (flength == 126 && 4 <= ret) {
 	flength = WS_NTOH16(header->u.s16.l16);
 	fhlen = 4;
@@ -703,6 +721,28 @@
 	flength = WS_NTOH64(header->u.s64.l64);
 	fhlen = 10;
 	mask = header->u.s64.m64;
+#else
+    } else if (flength == 126) {
+	fhlen = 4;
+	ret = ws_read(cl, buf + WSHLENMIN, (fhlen + 4) - WSHLENMIN);
+	if (ret != (fhlen + 4) - WSHLENMIN) {
+	    rfbLog("broken header");
+	    errno = EIO;
+	    goto spor;
+	}
+	flength = WS_NTOH16(header->u.s64.l64);
+	mask = header->u.s64.m64;
+    } else if (flength == 127) {
+	fhlen = 10;
+	ret = ws_read(cl, buf + WSHLENMIN, (fhlen + 4) - WSHLENMIN);
+	if (ret != (fhlen + 4) - WSHLENMIN) {
+	    rfbLog("broken header");
+	    errno = EIO;
+	    goto spor;
+	}
+	flength = WS_NTOH64(header->u.s64.l64);
+	mask = header->u.s64.m64;
+#endif
     } else {
       /* Incomplete frame header */
       rfbErr("%s: incomplete frame header\n", __func__, ret);
@@ -714,16 +754,28 @@
     total = fhlen + flength + 4;
     payload = buf + fhlen + 4; /* header length + mask */
 
+#if 0
     if (-1 == (ret = ws_read(cl, buf, total))) {
+#else
+    if (-1 == (ret = ws_read(cl, payload, flength))) {
+#endif
       int olderrno = errno;
       rfbErr("%s: read; %m", __func__);
       errno = olderrno;
       return ret;
+#if 0
     } else if (ret < total) {
+#else
+    } else if (ret < flength) {
+#endif
       /* GT TODO: hmm? */
       rfbLog("%s: read; got partial data\n", __func__);
     } else {
+#if 0
       buf[ret] = '\0';
+#else
+      buf[total] = '\0';
+#endif
     }
 
     /* process 1 frame (32 bit op) */
